// async/await is a special syntax to work with promises in a more comfortable fashion, called async/await
// Async functions, "async" keyword can be placed in front of function
async function f() {
  return 1;
}
// "async" before a function means, it will always return a promis
// other values are wrapped in a resolved promise automatically
f().then(alert);
// if we are to write it using Promise alternatively, it would have looked like like following
async function f2() {
  return Promise.resolve(2);
}
// and call would have been same as async usage
f2().then(alert);
// "async" ensures that a function returns a Promise and wraps non-Promiss in it
// there's another word "await" which works only inside "async" function

// Await
// syntax: let value = await Promise
// "await" keyword makes Javascript wait until that promises settles and returns it's result
async function ff() {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done"), 1001);
  });
  let result = await promise; // wait until promise resolves
  console.log(result);
}
ff();
// "await" literally suspends function execution until promise settles and then resumes with result
// that doesn't cost any CPU resources, because Javascript engiine can do other jobs mentime
// it's just a more elegant syntax of getting promise result than promie.then(), it's also easier to read and write
// "await" can only be used inside a async function, using otherwise would be a syntax error
async function showAvatar() {
  let response = await fetch("../sample.json");
  let tweets = await response.json();

  let githubResponse = await fetch("https://api.github.com/users/bappyasif");
  let githubUser = await githubResponse.json();

  // showing avatar
  let imgEl = document.createElement("img");
  imgEl.src = githubUser.avatar_url;
  imgEl.style.width = "20vw";
  document.body.insertAdjacentElement("afterbegin", imgEl);

  // wait a second to remove it
  // await new Promise((resolve,reject)=>setTimeout(()=>resolve,1001));
  await new Promise((resolve, reject) => setTimeout(resolve, 1001));
  imgEl.remove();
}
showAvatar();
// we should also remember that "await"can't be use top-level / global namespaced code, but this works in moules
// in order to "await" to work we need to use it within "async" labeled function of any valid kind

// "await" accepts "thenables"
// like promise.then, "await" allows us to use thenables objects
// idea is that a thirrd party object may not be a promise, , but promise-compatible
// if it supports .then(), that enough to use it use "await"
// herre  following is an example of a Thenable class, "await" below accepts it's instances
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    console.log(resolve);
    setTimeout(() => resolve(this.num * 2), 1001);
  }
}
async function tf() {
  // waits throughout setTimeout timer
  let result = await new Thenable(1);
  console.log(result);
}
tf();
// "await" waits until one of those built in function is called(resolv/reject) and then proceeds with result
// declarin async class methods
class Mediate {
  async wait() {
    return await Promise.resolve(11);
  }
}
// new Mediate().wait().then(alert);
new Mediate().wait().then((res) => console.log(res));
// meaning is just same, it ensures that returned value is a Promise and enables await

// Error Handling
// if a promise resolves normally, then "await" promise returns result, but in case of a rejection, it throws an error, just as if there were a "throw" statement there
// both of those two following snippets are same
async function exff() {
  await Promise.reject(new Error("uh oh"));
}
async function exff() {
  throw new Error("uh oh");
}
// in real life situations, promise might take a while before it rejects, hence there'll be delay before "await" throws an error
// we can catch that error using try..catch, same way as a regular throw
async function fe() {
  try {
    let response = await fetch("http://no-such-url");
  } catch (err) {
    console.log(err);
  }
}
fe();
// in case of an error, control jumps to catch, we can also wraps multiple lines
async function eh() {
  try {
    let response = await fetch("http://none-here");
    let user = await response.json();
  } catch (err) {
    // catches both errors in fetch and response.json()
    console.log(err);
  }
}
eh();
// if we dont use try..catch then prommise generated by call oof async function becomes rejected and we can use .catch() to handle it
async function af() {
  let response = await fetch("http://no-such");
}
// af() becomes rejected promise
af().catch((err) => console.log(err));
// if we forget to use .catch() there then we get an unhandled promise error, viewable in console
window.addEventListener("unhandledrejection", (evt) => {
  console.log("<>", evt.promise);
  console.log("><", evt.reason);
});
af();
// when we use async/await we rarely use then() because "await" handles waiting for us
// we can use a regular try..catch instead of catch() this is usually more convenient but not always
// at top level of code we are unable to use "await" soo we are lleft wiith then/catch to handle final result oor failing eirror
// async/await works well with Promise.all([..]) and then "await"
async function pa() {
  let results = await Promise.all([
    Promise.resolve(20),
    // Promise.resolve(02)
    Promise.reject("02"),
  ]);
  let values = await results;
  // console.log(values);
}
pa().catch((err) => console.log(err));
// or we can use try..catch to handle error
async function pb() {
  try {
    let results = await Promise.all([
      Promise.resolve(20),
      // Promise.resolve(02)
      Promise.reject("02"),
    ]);
    let values = await results;
    // console.log(values);
  } catch (err) {
    console.log(err);
  }
}
pb();

// summary
// "async" keyword before a function has two effects
// Makes it always return a promise
// allows "await" to be used in it
// "await" keyword before a promise makes Javascript wait until that promise settles
// if it's an error, exception is generated, same as throw error
// othersise, it returns result
// together they provide a great framework tooo write asynchronous code that is easy to read and write
// with async/await we rarely need to use then()/catch() unless they are scopen in top level or globally

// Tasks:
// 01: rewrite using async/await
// legacy code:
function loadJson(url) {
  return fetch(url).then((res) => {
    if (res.status === 200) {
      return res.json();
    } else {
      throw new Error(res.statusText);
    }
  });
}
loadJson("../sample.json")
  .then((vals) => console.log(vals))
  .catch((err) => console.log(err));
// refactored code  varsion 01:
async function jsonLoad(url) {
  try {
    let response = await fetch(url);
    let data = await response.json();
    console.log(data);
  } catch (err) {
    console.log(err);
  }
}
// jsonLoad("./friends.json");
jsonLoad("../friends.json");

// refactored code  varsion 02:
async function jsonLoader(url) {
  let response = await fetch(url);
  if (response.status === 200) {
    let data = await response.json();
    console.log(data);
  }
  throw new Error(response.statusText);
}
jsonLoader("../videos.json").catch((err) => console.log(err));

// task02: rewrite "rethrow" with async/await
// legacy code:
// class HttpError extends Error {
//     constructor(response) {
//         super(`${response.status} for ${response.url}`);
//         this.name = 'HttpError';
//         this.res = response;
//     }
// }
// function loadingJson(url) {
//     return fetch(url)
//     .then(res => {
//         if(res.status == 200) {
//             return res.json();
//         } else {
//             throw new HttpError(res);
//         }
//     })
// }
// // asking for uer name until github finds a valid user
// function demoUser() {
//     let name = prompt("enter name");
//     return loadingJson('https;//api.github.com/users/'+name)
//     .then(user => {
//         console.log(user);
//         return user;
//     }).catch(err => {
//         if(err instanceof HttpError && err.res.status === 404) {
//             console.log("no such user found, please retry");
//             return demoUser();
//         } else {
//             throw err;
//         }
//     })
// }
// demoUser();
class HttpError extends Error {
  constructor(response) {
    super(`${response.status} for ${response.url}`);
    this.name = "HttpError";
    this.response = response;
  }
}

function loadJson(url) {
  return fetch(url).then((response) => {
    if (response.status == 200) {
      return response.json();
    } else {
      throw new HttpError(response);
    }
  });
}

// Ask for a user name until github returns a valid user
function demoGithubUser() {
  let name = prompt("Enter a name?", "bappyasif");

  return loadJson(`https://api.github.com/users/${name}`)
    .then((user) => {
      alert(`Full name: ${user.name}.`);
      return user;
    })
    .catch((err) => {
      if (err instanceof HttpError && err.response.status == 404) {
        alert("No such user, please reenter.");
        return demoGithubUser();
      } else {
        throw err;
      }
    });
}
demoGithubUser();

// refactorred code: version 01:
async function githubUser() {
    let name = prompt("find user");
  try {
    let userResponse = await fetch(`https://api.github.com/users/${name}`);
    let user = await userResponse.json();
    console.log(user.login);
  } catch (err) {
    if (err instanceof HttpError && err.response.status === 404) {
      demoGithubUser();
    } else {
      throw err;
    }
  }
}

githubUser();

// refactored code: version 02:
async function userFind() {
    let name = prompt("find user");
  while(true) {
    try {
        let userResponse = await fetch(`https://api.github.com/users/${name}`);
        let user = await userResponse.json();
        console.log(user.login);
        break; // no error, break loop
      } catch (err) {
        if (err instanceof HttpError && err.response.status === 404) {
          userFind();
        } else {
          throw err;
        }
      }
  }
}
userFind();

// Task: 03: call "async" from non async
async function wait() {
    await new Promise((resolve,reject) => setTimeout(resolve,1001));
    return 10;
}
function nonAsync() {
    // we need to call async await() and wait to get 10
    // we can not use "await"
    wait().then(val=>console.log(val)).catch(err=>console.log(err));
}
nonAsync();